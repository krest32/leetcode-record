# 数据结构

## 数据结构基本概念

### 分类

+ 线性表
+ 栈、
+ 队列、
+ (字符)串、
+ 数组、
+ 广义表、
+ 树、
+ ==二叉树、==
+ 图

### 其他概念

+ 数据项
  + 最小的数据单位。比如：年龄29
+ 数据元素
  + 数据的基本单位。 比如 小明：{姓名、年龄}
+ 数据对象
  + 数据元素的集合
+ 数据结构
  + 相互之间处在一种或者多种特定关系的数据元素的集合，指数据的组织之间的名称
  + 逻辑结构：结构存在于逻辑思维领域，不考虑计算机的实现
  + 存储结构：数据在计算机的存储方式

### 总结：

数据结构=逻辑结构+存储结构+（在存储结构上的）运算/操作
数据结构的三个方面：

1. 逻辑结构
   1. 线性结构（顺序排列，从一而终）
      1. 线性表
      2. 栈
      3. 队列
      4. 串及数组
   2. 非线性结构（散装结构，如果文件资源管理器）
      1. 树形结构
      2. 图形结构（比较复杂，如星型网络结构、城市地铁图）
2. 数据存储结构
   1. 顺序存储 （数组、队列）==【必须事先准备数组的大小】==
   2. 链式存储（LinkedList）
      1. 单向链表
      2. 双向链表（==需要的存储空间也会更大==，因为每个节点要存储两个指针）
   3. 索引存储 （MySql中的InnoDB引擎：相当于目录，方便进行查找）
   4. 散列存储（哈希表：根据节点的关键字计算出该节点的存储位置）【添加、查询速度快】
3. 数据的运算
   1. 检索
   2. 排序
   3. 插入
   4. 删除
   5. 修改
   6. 等等



## 算法基本概念

​		计算机解题的思路，这个解题的过程都可以称为算法

**举例**

求 1+2+3+.....+100=?

算法1：依次相加

算法2：高斯算法：首位相加*50

算发3：使用递归实现：sum（100）=sum(99)+100 sum(99)=sum(98)+99......



==评价算法的优劣程度：复杂度（时间复杂度和空间复杂度）==

​		一般来说没有完全符合时间少空间小的算法，因为鱼和熊掌不可兼得

​		时间复杂度：消耗计算机的计算工作量

​		空间复杂度：消耗计算机的内存空间

### 算法的五个特征

1. 输入
2. 输出
3. 可行性
4. 有穷性
5. 确定性

### 时间复杂度

​		时间复杂度：消耗计算机的计算工作量，但是由于执行消耗的时间在不同机器上是不同的，所以计算时间的详细值没有意义，我们会见执行语句的条数作为衡量作为标准，称为时间频度T（n），但是时间频度计算也十分复杂，==我们需要了解问题的规模而非具体执行的次数，所以引入了时间复杂度==

​		T(n) = ==O(n²)==

#### 最坏时间复杂度

​		一般情况下会要求使用

​		T(n) = ==O(n²)==  就是最坏的时间复杂度

#### 平均时间复杂度

​		难以计算，所以不适用

### 时间复杂度的种类

常数	T(n) = O(1)  最好

对数	T(n) = O(n) 	正常的循环体

线性	T(n) = O(log n)	循环被砍掉一半，效率也会特别高

线性平方	T(n) = O(n*log n)	循环被砍掉一半，效率也会特别高

平方	T(n) = O(n²)	循环嵌套循环，最坏的时间复杂度

立方	T(n) = O(n³)	循环嵌套循环，最坏的时间复杂度

K次方	

指数立方

阶乘 N!

执行效率会越来越低



### 空间复杂度

​		空间复杂度：消耗计算机的内存空间

​		算法运行时会产生的临时工作单元，递归虽然说代码量少，但是整体会产生大量的临时工作单元，所以是最消耗系统资源的一种方式



## 线性表

### 基本概念

#### 概念

​		n个**类型相同数据元素**的有限序列（相同元素代表每个元素的内存空间是相同的，便于查询定位）

#### 实现方式

+ 集合
  + `ArrayList`
    + 节省空间，索引查询效率高（==查找第一个数据和第n个数据的效率是一样的==）
  + `LinkedList`
    + 存储的空间不是连续的，需要找到下一个元素的指针才能查找下一个元素。

### 数组

1.  数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
2.  连续的内存空间和相同类型的数据(随机访问的前提)。
3. 优点：两限制使得具有随机访问的特性缺点：删除，插入数据效率低。
4. 对内存空间要求高，需要一块连续的内存空间。

### `ArrayList`

#### 添加/修改方法

~~~java
 	// 向数组中的第一个null元素中添加数据
	@Override
    public boolean add(Object object) {
        this.add(size,object);
        return true;
    }

	// 向数组中的指定位置添加元素，同时该方法也可以当中是修改的方法
	@Override
    public void add(int index, Object element) {
        // 检查数组容量
        checkCapacity();
        // 检查数组是否满
        if (index>size){
            // 数组满就进行扩容
            size=index;
            grow();
        }
        // 向指定位置添加元素的时候，将每个元素的位置进行一次变动
        for (int i = size; i > index ; i--) {
            elementData[i] = elementData[i-1];
        }
        // 向数组中添加元素
        elementData[index] = element;
        size++;
    }
~~~

#### 查找方法

~~~java
    @Override
    public Object get(int index) {
        if ( index < 0 || index >= size){
            throw new MyException("Wrong index of MyArrayList to get element");
        }
        return  elementData[index];
    }
~~~

#### 数组的扩容

~~~Java
private void grow() {
    	//通过拷贝数据到更大的数组实现扩容
        elementData = Arrays.copyOf(elementData, (size << 1)-(size/2));
    }
~~~

#### 删除方法

~~~java
public E remove(int index) {
        // 判断用户输出的参数是否合法
    	rangeCheck(index);
        modCount++;
    	// 拷贝数组
        E oldValue = elementData(index);
        
    	int numMoved = size - index - 1;
    
        if (numMoved > 0){
            // 调用native的数组拷贝的方法
            System.arraycopy(elementData, index+1, elementData, index, numMoved);
        }
    	//
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
    }
	
	// 检查用户参数是否合法
    private void rangeCheck(int index) {
        if (index >= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
~~~



### `MyLinkedList`（单向链表）

​		链表是一种物理存储单元上**非连续、非顺序**的存储结构，**数据元素的逻辑顺序是通过链表中的指针链接次序实现**的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，

​		设计：为了使程序更加简洁，通常会在单链表的前面添加一个哑元节点（没有数据），也成为头结点，方便统一程序的样式，所以它在内存是不连续的存储空间，同时也可以存储不同的数据

#### 链表分类

+ 单线链表
+ 双向链表
  + 由于单项链表只能按照顺序进行查找，**而且添加/删除也比较浪费时间，所以引入了双向链表**，双向链表会增加两个哑元节点，一个头节点，一个尾节点
+ 循环列表
  + 循环单向链表
  + 循环双向链表（`LinkedList`）

#### 数据结构图

![image-20210103113607843](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210103113607.png)

#### 节点设计

~~~Java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class MyNode {
    /**
     * User data
     */
    Object data;

    /**
     * Next Node Data
     */
    MyNode nextNode;

    public MyNode(Object data) {
        this.data = data;
    }
}
~~~

#### 添加/修改方法

~~~java
 	// 向链表中的最后一个位置添加元素
	@Override
    public boolean add(Object object) {
        this.add(size,object);
        return true;
    }

	// 向指定位置添加元素
	@Override
    public void add(int index, Object element) {
        // 检查链表的参数否非是否合适
        checkIndex(index);
        // find prev node, from head node
        MyNode p = headNode;
        // 通过遍历，找到index的前一个节点
        for (int i = 0; i < index; i++) {
            p=p.nextNode;
        }
        // create new node
        MyNode newNode = new MyNode();
        newNode.data=element;
        //  indicate next node
        newNode.nextNode=p.nextNode;
        // indicate prev node
        p.nextNode=newNode;
       、// 确认链表的长度
        size++;
    }

    private void checkIndex(int index) {
        if (index>size){
            throw new MyException("index out of limit");
        }
    }

~~~

#### 查找方法

~~~java
    @Override
    public Object get(int index) {
        // 检查传入的参数
        checkIndex(index);
        MyNode p= headNode;
        for (int i = 0; i <index ; i++) {
            p=p.nextNode;
        }
        return p.data;
    }
     private void checkIndex(int index) {
         if (index>size){
             throw new MyException("index out of limit");
         }
     }
~~~





### 其他线性表

#### 栈

##### 概念

​	运算受限制的线性表，只能在一端进行操作

##### 特点

+ 先进后出，主要在内存中操作



#### 队列

##### 概念

​	运算受限制的线性表，只能在一端进行操作



##### 特点

+ 先进先出，如消息队列



## 树

### 特点

+ 根节点
+ 父节点
+ 兄弟节点：同深度的节点
+ 叶子节点：最底层节点
+ 度：某个节点的子节点最多的个数，比如度是5
+ 树的深度：根在第一层，叶子节点在最底层，代表树有几层
+ 有序树：同一层节点，从左到右有顺序的树（==考虑每一层节点从左到右是否有顺序==）
+ 森林：有m棵不相交的树的集合
+ m叉树：每个节点最多有m的子节点，就被叫做m叉树



### 二叉树（重点）

#### 概念

+ 每个节点做多只有两个子节点
+ 左子树：左边节点及所有子节点
+ 右子树：右边节点及所有子节点
+ 左节点：只是左节点
+ 右节点：只是y右节点
+ 满二叉树：每个节点都有两个子节点
+ 完全二叉树：叶子节点是数
  + 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树



### 重点树

+ 二叉搜索树：左子树的值小于父节点，右子树的值大于根节点
+ 二叉平衡树：它是二叉搜索树的改进，就是左右字数的高度差的不会超过1；
+ 强平衡二叉树AVL：追求完美平衡，节点数量相同的情况下，AVL的高度低于红黑树，但是AVL的旋转操作比红黑树更加麻烦
+ 弱平衡二叉树：增加了节点的颜色，同时，左右字数的高度差的绝对值不会超过1



#### 存储结构

##### 顺序存储

​		所有数据按照顺序进行存储，但是实际情况用的比较少，因为很少有数据能够按照顺序存储到树中

##### 链式存储（使用较多）

​		每个节点的数据中保存了==左节点和右节点的数据信息（内存地址）==，所以查找依赖会比较方便

​		叶子节点的左右两个数据单元信息为null

缺点： 没有父节点的信息，只能暗转顺序进行存储，

解决方法：每个节点存储父节点数据，如下图，==数据单元的图示==：

![image-20210103132948880](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210103132948.png)

#### 节点设计

~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MyTreeNode {
    /**
     * Node Value
     */
    Object value;

    /**
     * leftChildNode
     */
    MyTreeNode leftChild;

    /**
     * rightChildNode
     */
    MyTreeNode rightChild;

}

~~~

#### 获取树的深度

~~~Java
	@Override
    public int getHeight() {
        return this.getHeight(rootNode);
    }

    private int getHeight(MyTreeNode node){
        if (node!=null){
            int leftHeight = this.getHeight(node.leftChild);
            int rightHight = this.getHeight(node.rightChild);
            return leftHeight>rightHight ? leftHeight+1 :rightHight+1 ;
        }else {
            return 0;
        }
    }
~~~

#### 获取某个节点的数据

~~~java
    @Override
    public Object findKey(Object value) {
        return this.findKey(value,rootNode);
    }

    public Object findKey(Object value,MyTreeNode node) {
        if(node==null){
            return null;
        }else if(node != null && node.value == value) {
            return node;
        }else{
            MyTreeNode node1 =(MyTreeNode)this.findKey(value,node.leftChild);
            MyTreeNode node2 =(MyTreeNode)this.findKey(value,node.rightChild);
            if (node1 !=null && node1.value == value){
                return node1;
            }else if (node2 !=null && node2.value == value){
                return node2;
            } else {
                return null;
            }
        }

    }

~~~

#### 获取树的节点个数

~~~java
    @Override
    public int size() {
        return this.size(rootNode);
    }

    public int size(MyTreeNode node) {
        if (node!=null){
            int left = this.size(node.leftChild);
            int right = this.size(node.rightChild);
            return left+right+1 ;
        }else {
            return 0;
        }
    }
~~~









#### 二叉树的遍历

原理：访问树中的所有节点，且每个节点点仅访问一次，也就是将非线性结构，人为的转化为线性结构

流程：

+ 第一种：（可以使用递归来遍历）将整个二叉树看作三部分，根、左子树、右子树，==给出后序遍历和中序遍历，我们可以得到先序遍历的序列==

  + 先序遍历：根->左子树->右子树
  + 中序遍历：左子树->根->右子树
  + 后序遍历：左子树->右子树->根

  <img src="https://duxin2010.oss-cn-beijing.aliyuncs.com/20210103135345.png" alt="image-20210103135345057" style="zoom: 80%;" />

+ 第二种：按照层次来遍历（不常用，且不能使用递归遍历），代码难以实现

##### 中序遍历->递归

~~~java
    @Override
    public void inOrderByRecursion() {
        // root node
        this.inOrderByRecursion(rootNode);
    }

    private void inOrderByRecursion(MyTreeNode node) {
        // root node
        if (node != null) {
            // life child order
            this.inOrderByRecursion(node.leftChild);

            // root order
            System.out.print(node.value+" ");

            // right child order
            this.inOrderByRecursion(node.rightChild);
        }
    }
~~~

##### 先序遍历->递归

~~~java

    @Override
    public void preOrderByRecursion() {
        // root node
        if (rootNode!=null){
            System.out.print(rootNode.value+" ");
            MyBinaryTree leftTree = new MyBinaryTree(rootNode.leftChild);
            leftTree.preOrderByRecursion();
            MyBinaryTree rightTree = new MyBinaryTree(rootNode.rightChild);
            rightTree.preOrderByRecursion();
        }

    }
~~~

##### 后序遍历->递归

~~~~~java

    @Override
    public void postOrderByRecursion() {
        this.postOrderByRecursion(rootNode);
    }

    private void postOrderByRecursion(MyTreeNode node) {
        // root node
        if (node != null) {
            // life child order
            this.postOrderByRecursion(node.leftChild);
            // right child order
            this.postOrderByRecursion(node.rightChild);
            // root order
            System.out.print(node.value+" ");
        }
    }
~~~~~



##### 通过双端队列遍历

~~~~java
    @Override
    public void inOrderByStack() {
        // Deque是双端队列（栈操作推荐使用） -> 中序非递归方法，但是整体的逻辑会非常复杂
        Deque<MyTreeNode> stack = new LinkedList<>();
        MyTreeNode current = rootNode;
        while(current!=null || !stack .isEmpty()){
            while (current !=null ){
                stack.push(current);
                current = current.leftChild;
            }
            if (!stack.isEmpty()){
                current= stack.pop();
                System.out.print(current.value+" ");
                current = current.rightChild;
            }
        }
    }

~~~~

##### 通过栈去遍历

~~~~java
    @Override
    public void levelOrderByStack() {
        if (rootNode!= null){
            Queue<MyTreeNode> queue = new LinkedList<>();
            queue.add(rootNode);
            while (queue.size()!=0){
                int len =queue.size();
                for (int i = 0; i < len; i++) {
                    MyTreeNode temp = queue.poll();
                    System.out.print(temp.value+" ");
                    if (temp.leftChild!=null) {
                        queue.add(temp.leftChild);
                    }
                    if (temp.rightChild!=null) {
                        queue.add(temp.rightChild);
                    }
                }
            }
        }
    }
~~~~



## 红黑树图解

### 定义
​		红黑树是一颗 红-黑的平衡二叉树,它具有二叉树的所有特性,是一颗自平衡的排序二叉树.

​		(树中任何节点值都大于左子节点的值，而且都小于右子节点的值),

​		其检索效率高，

​		它是一颗空树或它的左右两个子树高度差的绝对值不超过1，

​		并且左右子树都是平衡二叉树.	

![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107161806.png)
		最坏的情况下 是一边倒的情况
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107161811.png)

​		在这种情况下，如果我们要在树中查找节点，就需要顺着根节点往下找,时间复杂度约为O(n)常数级。那么红黑树具有以下特点，使得它的查找时间复杂度为O(lg n)

![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107161834.png)

### 性质

1. 每一个节点 必须为红色或者黑色

2. 根节点是黑色的

3. 每个叶子节点（nil节点 空节点是黑色的）

4. 如果一个节点是红色的，那么它的叶子节点都是黑色的(同一个路径下 不允许出现两个相邻的红色节点)

5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点（黑节点的数目称为黑高black-height）

6. 从根到叶子节点的最大路径不能大于最短路径的两倍长,大致上是平衡的，插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例。

7. 如果查找、插入、删除频率差不多，那么选择红黑树。

   

### 插入

​		默认插入的节点为红色,因为黑色节点的数量为红色节点数量的两倍多,因此插入节点的父节点为黑色的概率很大,不需要做任何调整，效率较高.

1.父为黑
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162412.png)
		这种情况下，直接插入，且插入后无需任何操作，黑色节点的数量多与红色节点的数量（2倍左右）,因此父为黑这种概率比较大，效率比`AVL`树高。

2.父为红
		这种情况破坏了红黑树的特点(相同路径下不能出现两个相邻的红色节点),因此，因此要跟据叔叔的颜色 做不同的插入处理
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162818.png)

图中叔叔的颜色也有两种可能 暂时以蓝色表示
1),叔叔为红
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162508.png)

2),叔叔为黑(这种情况有比较复杂)
a.父在左，叔叔在右，新节点在左
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162512.png)

b,父在左 叔叔在右，新在右
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162523.png)

c,父在右，叔在左 ，新在右
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162529.png)

d,父在右，叔叔在左，新在左
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162543.png)



### 删除

删除一颗普通的二叉排序树 有三种情况
1.叶子节点
2.只有左子树或只有右子树的节点
3.既有左子树 又有右子树的节点

​		对于情况3来讲，我们的思路是先找到待删除节点的后继节点（左孩子节点或右孩子节点），然后用孩子节点的值将待删除节点的值覆盖,最后按1,2中的方法删除孩子节点即可
​		对情况2来讲，待删除节点只有左子树或右子数,有很多组合，在红黑树中是不存在的，违背了红黑树的性质,图中 C代表待删节点，CR表示右孩子，CL表示左孩子
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162611.png)
图中这四种情况都违背了红黑树性质5,不会存在
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162614.png)
此图中 违背了性质4
1，待删除的节点为红色
C 代表要删除的节点，P代表父节点
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162617.png)
上面这两种情况 处理方式都一样，直接删除C就好
另外待删除的红色节点，只有左子树或右子树 这种情况是不存在的（已探讨）
2,接下来，讨论最复杂的情况，待删除的节点为黑色节点
a,删除黑色的叶子节点
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162621.png)
这种情况相对复杂,后面细分
删除的黑色节点 仅有左子树或仅有右子树
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162625.png)
对于这种情况，我们用子节点覆盖调节点C，并且将C 的子节点的颜色改为黑色 ，（因此路径上少了一个黑节点,所以将红色节点变为黑色节点以保证红黑树的性质）
a.1:待删除的叶子节点兄弟节点为红色
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162631.png)
c为父节点的左子节点的情况，做法是将兄弟节点b和父节点p的颜色互换，同时将兄弟节点p左旋转
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162635.png)
此时C的兄弟节点变成了黑色 这就是我们后面要讨论的情况

c是右子节点的情况,同上，将兄弟节点b和父节点p的颜色互换，同时将兄弟节点p右旋转
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162638.png)

![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162643.png)
此时c的兄弟节点也变成了黑色 ，这也是我们后面要谈论的情况
a.2:兄弟节点为黑色，且远侄子节点为红色
c为左孩子的情况，这时c的远侄子节点为b的右孩子
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107162650.png)
		没有上色的节点表示为红黑均可,如果bL为黑色，则bL则必为null节点,如果删除c，那么经过c节点的黑节点个数就少一个,但如果我们能把bR节点移到左侧，并改为黑色,就满足红黑树的特点了,(p节点的颜色不影响，因为整个调整过程是在p子树内部进行的)
调整过程为将b和p颜色对调,将b进行左旋转(L操作)，同时将远侄子节点bR变为黑色,删除掉c
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118184732761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)
c为右孩子的情况，此时c的远侄子为b的左孩子
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118190244667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)
同样，将b节点和p节点颜色对调，然后将以b节点为起始，向右旋转,将c的远侄子节点bL变成黑色 删除掉c
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118190547643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)

a.3:兄弟节点为黑色，远侄子节点为黑色，近侄子节点为红色.

c为左孩子，近侄子节点为兄弟节点的左孩子

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118191527518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)





此时将bL节点右旋(R操作),将b节点和bL节点颜色对调
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118193535918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)
这时候就变成了a.4的情况
c为右孩子，近侄子节点为兄弟节点的右孩子 且为红节点
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118193242688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)
做法是将bL节点左旋（L操作），将b节点和bL节点颜色对调
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118195639501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEyNjM3,size_16,color_FFFFFF,t_70)
这样就变成了a.4

a.4:父亲节点为红色，且兄弟节点和兄弟节点的两个孩子节点(只能是null节点)都为黑色 的情况
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107163233.png)
如果删除节点c，那么经过p和c的节点的黑节点就少了一个，这个时候我们可以把p变为黑色,这个时候 删除c节点经过c的子节点（空节点）的路径上的黑节点就和原来一样了,但是经过b节点的路径上就多了一个黑节点，所以我们可以把b变成红节点，这样经过b的路径上的黑色节点就和原来一样了

做法是 将父节点p变成黑色，将b节点变成红色
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107163236.png)

a.5:父亲节点，兄弟节点 以及兄弟节点的孩子（只能是null节点）都为黑色的情况
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107163240.png)
方法是将b节点改为红色，这样删除c以后p的左右子树上的黑节点的个数就相同了，但是这样 经过b节点的路径上的黑节点就少了一个,这个时候，我们再以p为起始点，继续根据情况进行平衡操作（这句话的意思就是把p当成c（只是不要再删除p了），再看是那种情况，再进行对应的调整，这样一直向上，直到新的起始点为根节点）
网页工具:https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107163242.png)
![在这里插入图片描述](https://duxin2010.oss-cn-beijing.aliyuncs.com/20210107163246.png)
判断类型的时候，先看待删除的节点的颜色，再看兄弟节点的颜色，再看侄子节点的颜色（侄子节点先看远侄子再看近侄子），最后看父亲节点的颜色

## 红黑树代码

### 概述

`TreeMap`是红黑树的`java`实现，红黑树能保证增、删、查等基本操作的时间复杂度为O(lgN)。
首先我们来看一张TreeMap的继承体系图：

![image](https://upload-images.jianshu.io/upload_images/1696815-681ce4a34941f871.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
还是比较直观的，这里来简单说一下继承体系中不常见的接口NavigableMap和SortedMap，这两个接口见名知意。先说NavigableMap接口，NavigableMap接口声明了一些列具有导航功能的方法，比如：

```java
/**
 * 返回红黑树中最小键所对应的 Entry
 */
Map.Entry<K,V> firstEntry();

/**
 * 返回最大的键 maxKey，且 maxKey 仅小于参数 key
 */
K lowerKey(K key);

/**
 * 返回最小的键 minKey，且 minKey 仅大于参数 key
 */
K higherKey(K key);

// 其他略12345678910111213141516
```

通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。至于 SortedMap 接口，这个接口提供了一些基于有序键的操作，比如:

```java
/**
 * 返回包含键值在 [minKey, toKey) 范围内的 Map
 */
SortedMap<K,V> headMap(K toKey);();

/**
 * 返回包含键值在 [fromKey, toKey) 范围内的 Map
 */
SortedMap<K,V> subMap(K fromKey, K toKey);

// 其他略1234567891011
```

以上就是两个接口的介绍，很简单。至于AbstractMap和Map这里就不说了，大家有兴趣自己去看看Javadoc吧。关于TreeMap的继承体系就这里就说到这，接下来我们进入细节部分分析。

### 源码分析

#### 添加

红黑树最复杂的无非就是增删了，这边我们先介绍增加一个元素，了解红黑树的都知道，当往 TreeMap 中放入新的键值对后，可能会破坏红黑树的性质。首先我们先巩固一下红黑树的特性。

- 节点是红色或黑色。
- 根节点是黑色。
- 每个叶子节点都是黑色的空节点（NIL节点）。
- 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

接下来我们看看添加到底做了什么处理：

```java
    public V put(K key, V value) {
        TreeMapEntry<K,V> t = root;
        if (t == null) {

            if (comparator != null) {
                if (key == null) {
                    comparator.compare(key, key);
                }
            } else {
                if (key == null) {
                    throw new NullPointerException("key == null");
                } else if (!(key instanceof Comparable)) {
                    throw new ClassCastException(
                            "Cannot cast" + key.getClass().getName() + " to Comparable.");
                }
            }
            root = new TreeMapEntry<>(key, value, null);
            size = 1;
            modCount++;
            return null;
        }
        int cmp;
        TreeMapEntry<K,V> parent;
        Comparator<? super K> cpr = comparator;
        if (cpr != null) {
            do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        else {
            if (key == null)
                throw new NullPointerException();
            @SuppressWarnings("unchecked")
                Comparable<? super K> k = (Comparable<? super K>) key;
            do {
                parent = t;
                cmp = k.compareTo(t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
        }
        TreeMapEntry<K,V> e = new TreeMapEntry<>(key, value, parent);
        if (cmp < 0)
            parent.left = e;
        else
            parent.right = e;
        fixAfterInsertion(e);
        size++;
        modCount++;
        return null;
    }
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263
```

这边会先把根节点暂存依赖，如果根节点为null，则讲新增的这个节点设为根节点。 如果初始化的时候指定了comparator比较器，则讲其插入到指定位置，否则使用key进行比较并且插入。不断的进行比较，找到没有子节点的节点，将其插入到相应节点。(注：如果查找出有相同的值只会更新当前值，cmp小于0是没有左节点，反之没有右节点。)

新插入的树破环的红黑树规则，我们会通过fixAfterInsertion去进行相应的调整，这也是TreeMap插入实现的重点，具体我们看看他是怎么通过java实现的。

```java
    private void fixAfterInsertion(TreeMapEntry<K,V> x) {
        x.color = RED;

        while (x != null && x != root && x.parent.color == RED) {
            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                TreeMapEntry<K,V> y = rightOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == rightOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateLeft(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } else {
                TreeMapEntry<K,V> y = leftOf(parentOf(parentOf(x)));
                if (colorOf(y) == RED) {
                    setColor(parentOf(x), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    x = parentOf(parentOf(x));
                } else {
                    if (x == leftOf(parentOf(x))) {
                        x = parentOf(x);
                        rotateRight(x);
                    }
                    setColor(parentOf(x), BLACK);
                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        root.color = BLACK;
    }12345678910111213141516171819202122232425262728293031323334353637383940
```

首先将新插入的节点设置为红色，这边做了一个判断，新节点不为null，新节点不为根节点并且新节点的父节点为红色。才会进入内部的判断，因为其本身就是一个红黑树。如果新节点的父节点为黑色，则他依旧满足红黑树的特性。所以当其父节点为红色进入内部的判断。

如果新节点是其祖父节点的左子孙，则拿到其祖父节点的右儿子，也就是新节点的叔叔。如果叔叔节点是红色。则将其父节点设为黑色，讲叔父节点设为黑色，然后讲新节点直接其祖父节点。

否则如果新节点是其父节点的右节点，以其父节点进行左转，将父节点设为黑色，祖父节点设为红色，在通过祖父节点进行右转。

else内容和上述基本一致。自己分析~~

最后我们还需要将跟节点设为黑色。

我们稍微看一下，他是怎么进行左转和右转的。

```java
// 右旋与左旋思路一致，只分析其一
// 结果相当于把p和p的儿子调换了
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        // 取出p的右儿子
        Entry<K,V> r = p.right;
        // 然后将p的右儿子的左儿子，也就是p的左孙子变成p的右儿子
        p.right = r.left;
        if (r.left != null)
            // p的左孙子的父亲现在是p
            r.left.parent = p;

        // 然后把p的父亲，设置为p右儿子的父亲
        r.parent = p.parent;
        // 这说明p原来是root节点
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}

//和左旋类似
private void rotateRight(Entry<K,V> p) {
    // ...
}
12345678910111213141516171819202122232425262728293031
```

下面我们通过图解来看看如何插入一颗红黑树。

现有数组int[] a = {1, 10, 9, 2, 3, 8, 7, 4, 5, 6};我们要将其变为一棵红黑树。

首先插入1，此时树是空的，1就是根结点，根结点是黑色的：
![img](https://upload-images.jianshu.io/upload_images/1696815-35a1bbe604cb8c41.png?imageMogr2/auto-orient/strip|imageView2/2/w/244)
然后插入元素10，此时依然符合规则，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-ff8c5a919580f81e.png?imageMogr2/auto-orient/strip|imageView2/2/w/287)
当插入元素9时，这时是需要调整的第一种情况，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-9ba8b4702a5ccb43.png?imageMogr2/auto-orient/)
红黑树规则4中强调不能有两个相邻的红色结点，所以此时我们需要对其进行调整。调整的原则有多个相关因素，这里的情况是，父结点10是其祖父结点1（父结点的父结点）的右孩子，当前结点9是其父结点10的左孩子，且没有叔叔结点（父结点的兄弟结点），此时需要进行两次旋转，第一次，以父结点10右旋：
![img](https://upload-images.jianshu.io/upload_images/1696815-d0a0094712f3f636.png?imageMogr2/auto-orient/strip|imageView2/2/w/418)
然后将父结点（此时是9）染为黑色，祖父结点1染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-5ec451ae4be9fade.png?imageMogr2/auto-orient/strip|imageView2/2/w/388)
然后以祖父结点1左旋：
![img](https://upload-images.jianshu.io/upload_images/1696815-535e491db3892667.png?imageMogr2/auto-orient/strip|imageView2/2/w/419)
下一步，插入元素2，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-c18a66f11e31be0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/438)
此时情况与上一步类似，区别在于父结点1是祖父结点9的左孩子，当前结点2是父结点的右孩子，且叔叔结点10是红色的。这时需要先将叔叔结点10染为黑色，再进行下一步操作，具体做法是将父结点1和叔叔结点10染为黑色，祖父结点9染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-69b50e3c6241ab62.png?imageMogr2/auto-orient/strip|imageView2/2/w/436)
由于结点9是根节点，必须为黑色，将它染为黑色即可：
![img](https://upload-images.jianshu.io/upload_images/1696815-34e3a7b1afb16d80.png?imageMogr2/auto-orient/strip|imageView2/2/w/469)
下一步，插入元素3，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-d3d694d87d7c1d13.png?imageMogr2/auto-orient/strip|imageView2/2/w/564)
这和我们之前插入元素10的情况一模一样，需要将父结点2染为黑色，祖父结点1染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-8d108c4affa887d2.png?imageMogr2/auto-orient/strip|imageView2/2/w/540)
然后左旋：
![img](https://upload-images.jianshu.io/upload_images/1696815-909caf30d48238a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/564)
下一步，插入元素8，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-17b865fc276fe39c.png?imageMogr2/auto-orient/)

此时和插入元素2有些类似，区别在于父结点3是右孩子，当前结点8也是右孩子，这时也需要先将叔叔结点1染为黑色，具体操作是先将1和3染为黑色，再将祖父结点2染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-61a7d217f606e28c.png?imageMogr2/auto-orient/strip|imageView2/2/w/576)
此时树已经平衡了，不需要再进行其他操作了，现在插入元素7，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-0d78f35604abc594.png?imageMogr2/auto-orient/strip|imageView2/2/w/651)
这时和之前插入元素9时一模一样了，先将7和8右旋，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-a1f934e4c694ba19.png?imageMogr2/auto-orient/strip|imageView2/2/w/601)
然后将7染为黑色，3染为红色，再进行左旋，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-c5f6e64b47891e41.png?imageMogr2/auto-orient/strip|imageView2/2/w/562)
下一步要插入的元素是4，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-2fb2e858239c5a0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/502)
这里和插入元素2是类似的，先将3和8染为黑色，7染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-2d9a16d1c42b6656.png?imageMogr2/auto-orient/strip|imageView2/2/w/552)
但此时2和7相邻且颜色均为红色，我们需要对它们继续进行调整。这时情况变为了父结点2为红色，叔叔结点10为黑色，且2为左孩子，7为右孩子，这时需要以2左旋。这时左旋与之前不同的地方在于结点7旋转完成后将有三个孩子，结果类似于下图：
![img](https://upload-images.jianshu.io/upload_images/1696815-a4a09d6cf4573d73.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
这种情况处理起来也很简单，只需要把7原来的左孩子3，变成2的右孩子即可，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-f85544254fa720cb.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
然后再把2的父结点7染为黑色，祖父结点9染为红色。结果如下所示：

![img](https://upload-images.jianshu.io/upload_images/1696815-ecbd91f1666f68fc.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
此时又需要右旋了，我们要以9右旋，右旋完成后7又有三个孩子，这种情况和上述是对称的，我们把7原有的右孩子8，变成9的左孩子即可，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-e58aa96c8a51937f.png?imageMogr2/auto-orient/strip|imageView2/2/w/660)
下一个要插入的元素是5，插入后如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-b7156fb8bd565f3f.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
有了上述一些操作，处理5变得十分简单，将3染为红色，4染为黑色，然后左旋，结果如下所示：

![img](https://upload-images.jianshu.io/upload_images/1696815-c25e4072e38d251d.png?imageMogr2/auto-orient/strip|imageView2/2/w/695)
最后插入元素6，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-a2ac80fe41126b77.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
又是叔叔结点3为红色的情况，这种情况我们处理过多次了，首先将3和5染为黑色，4染为红色，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-cacb2a4186cdd86e.png?imageMogr2/auto-orient/strip|imageView2/2/w/690)

此时问题向上传递到了元素4，我们看2、4、7、9的颜色和位置关系，这种情况我们也处理过，先将2和9染为黑色，7染为红色，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-316fe05167eef9f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
最后7是根结点，染为黑色即可，最终结果如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-83a06b538b720acc.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
可以看到，在插入元素时，叔叔结点是主要影响因素，待插入结点与父结点的关系决定了是否需要多次旋转。

### 删除

除了添加操作，红黑树的删除也是很麻烦的…我们看看怎么通过java去实现红黑树的删除。具体代码如下：

```java
  public V remove(Object key) {
        TreeMapEntry<K,V> p = getEntry(key);
        if (p == null)
            return null;

        V oldValue = p.value;
        deleteEntry(p);
        return oldValue;
    }123456789
```

其内部是通过deleteEntry去进行删除的。所以我们具体看看deleteEntry的实现。

```java
 private void deleteEntry(TreeMapEntry<K,V> p) {
        modCount++;
        size--;

        if (p.left != null && p.right != null) {
            TreeMapEntry<K,V> s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        } 

        TreeMapEntry<K,V> replacement = (p.left != null ? p.left : p.right);

        if (replacement != null) {
            // Link replacement to parent
            replacement.parent = p.parent;
            if (p.parent == null)
                root = replacement;
            else if (p == p.parent.left)
                p.parent.left  = replacement;
            else
                p.parent.right = replacement;

            p.left = p.right = p.parent = null;

            // Fix replacement
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) { 
            root = null;
        } else {
            if (p.color == BLACK)
                fixAfterDeletion(p);

            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }
1234567891011121314151617181920212223242526272829303132333435363738394041424344
```

根据上述代码，我们可以看出，如果 p 有两个孩子节点，则找到后继节点，并把后继节点的值复制到节点 P 中，并让 p 指向其后继节点。 然后将 replacement parent 引用指向新的父节点，同时让新的父节点指向 replacement。

然后判断如果删除的节点 p 是黑色节点，则需要进行调整。删除的是根结点并且树中只有一个节点，我们将根结点置为null，否则，如果删除的节点没有子节点并且是黑色，则需要调整。最后将p从树中移除。

删除了一个元素，为了保证还是一个红黑树，我们需要将其进行调整，具体代码如下：

```java
  /** From CLR */
    private void fixAfterDeletion(TreeMapEntry<K,V> x) {
        while (x != root && colorOf(x) == BLACK) {
            if (x == leftOf(parentOf(x))) {
                TreeMapEntry<K,V> sib = rightOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                if (colorOf(leftOf(sib))  == BLACK &&
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } else { // symmetric
                TreeMapEntry<K,V> sib = leftOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                if (colorOf(rightOf(sib)) == BLACK &&
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(leftOf(sib), BLACK);
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162
```

如果替换节点是父节点的左节点，并且替换节点的兄弟节点是红色，那我们需要将兄弟节点变成黑色，将父节点变成红色，并且通过父节点进行左旋转，然后将父节点的右节点设为兄弟节点。

如果兄弟节点的左右节点都是黑色的，那么将兄弟节点置为红色，并且将当前节点指向父节点。若兄弟节点的右节点是黑色，我们需要将兄弟节点的左节点设为黑色，将兄弟节点设为红色，然后以兄弟节点进行右旋转，然后更新兄弟节点。然后设置兄弟节点的颜色为右节点的颜色，然后将父节点和兄弟节点的左节点设为黑色，最后进行右旋转。最后将根结点设为黑色。

下面我们依旧通过图解来看看红黑树的删除操作：要从一棵红黑树中删除一个元素，主要分为三种情况。

#### 待删除元素没有孩子

没有孩子指的是没有值不为NIL的孩子。这种情况下，如果删除的元素是红色的，可以直接删除，如果删除的元素是黑色的，就需要进行调整了。

例如我们从下图中删除元素1：
![img](https://upload-images.jianshu.io/upload_images/1696815-83a06b538b720acc.png?imageMogr2/auto-orient/strip|imageView2/2/w/700)
删除元素1后，2的左孩子为NIL，这条支路上的黑色结点数就比其他支路少了，所以需要进行调整。

这时，我们的关注点从叔叔结点转到兄弟结点，也就是结点4，此时4是红色的，就把它染为黑色，把父结点2染为红色，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-f737fd511ace7c59.png?imageMogr2/auto-orient/strip|imageView2/2/w/546)
然后以2左旋，结果如下：
![img](https://upload-images.jianshu.io/upload_images/1696815-397740fe3c66a61b.png?imageMogr2/auto-orient/strip|imageView2/2/w/659)
此时兄弟结点为3，且它没有红色的孩子，这时只需要把它染为红色，父结点2染为黑色即可。结果如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-3d11a41c472be825.png?imageMogr2/auto-orient/strip|imageView2/2/w/578)

#### 待删除元素有一个孩子

这应该是删除操作中最简单的一种情况了，根据红黑树的定义，我们可以推测，如果一个元素仅有一个孩子，那么这个元素一定是黑色的，而且其孩子是红色的。

假设我们有一个红色节点，它是树中的某一个节点，且仅有一个孩子，那么根据红色节点不能相邻的条件，它的孩子一定是黑色的，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-30f74e1b529a7a44.png?imageMogr2/auto-orient/strip|imageView2/2/w/248)

但这个子树的黑高却不再平衡了（注意每个节点的叶节点都是一个NIL节点），因此红色节点不可能只有一个孩子。

而若是一个黑色节点仅有一个孩子，如果其孩子是黑色的，同样会打破黑高的平衡，所以其孩子只能是红色的，如下所示：
![img](https://upload-images.jianshu.io/upload_images/1696815-ca6a1d1ad7552c51.png?imageMogr2/auto-orient/strip|imageView2/2/w/259)
只有这一种情况符合红黑树的定义，这时要删除这个元素，只需要使用其孩子代替它，仅代替值而不代替颜色即可，上图的情况删除完后变为：

![img](https://upload-images.jianshu.io/upload_images/1696815-960e6415ce61c50b.png?imageMogr2/auto-orient/strip|imageView2/2/w/223)
可以看到，树的黑高并没有发生变化，因此也不需要进行调整。

#### 待删除元素有两个孩子

我们知道如果删除一个有两个孩子的元素，可以使用它的前驱或者后继结点代替它。因为它的前驱或者后继结点最多只会有一个孩子，所以这种情况可以转为上述两种情况进行处理。

### 查找

说了最复杂的添加和删除，我们再来看看查找，这里就简单很多了，具体代码如下：

```java
public V get(Object key) {
    Entry<K,V> p = getEntry(key);
    return (p==null ? null : p.value);
}

final Entry<K,V> getEntry(Object key) {
    // Offload comparator-based version for sake of performance
    if (comparator != null)
        return getEntryUsingComparator(key);
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
    Entry<K,V> p = root;

    // 查找操作的核心逻辑就在这个 while 循环里
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp < 0)
            p = p.left;
        else if (cmp > 0)
            p = p.right;
        else
            return p;
    }
    return null;
}
```

这个流程算比较简单了，上面注释标明了，这边就不再解释了。

### 总结

这边通过图+代码的形式将红黑树的特点展现出来。可以通过上面描述可见，红黑树并没有那么难…





## 图（多对多）

### 问题： 

#### 两个地点之间的路线选择问题？

 	1. 如何选择线路
 	 +  数据结构是图
 	2. 各个地点线路之间，是如何存储的
 	 + 图的存储结构有很多种
 	   + 顺序存储
 	   + 链式存储
 	3. 如何计算出两个地点之间合理路径（路径短、拥堵少、红绿的少）
 	 + 设计路径的问题

### 概念

+ 顶点
+ 顶点关系的集合：可以有一个加权图：代表选择的权重
+ 无向图=双向图
+ 单向图
+ 存储结构
  + 邻接矩阵： 二维数组 顺序结构
  + 邻接表：链表、链式存储结构

### 遍历方法

​		从图的某个顶点出发，按照某种方法，将图中所有顶点访问且仅访问一次，图的遍历时求解图的连通性、拓扑排序和求关键路径等算法的基础

+ 深度优先遍历：类似树的先根遍历
+ 广度优先遍历：类似树的层次遍历



### 最短路径

主要方法：不去计算详细值，而是用过权重来进行判断



+ 顶点最少
  + 广度优先搜索，通过树的层次遍历来实现，通过队列来实现
+ 权重最高（权重可以代表时间、距离等）
  + 根据权重得到最短路径问题的答案

## 查找

### 顺序查找

​		（无序线性表）按照数据的顺序来查找，效率会比较低，但是也是最简单的方法

~~~java
public class OrderSerach {
    public static void main(String[] args) {
        int[] arr= {21,321,324,43,54,76,8,23};

        int score = 43;

        int flag = -1;

        for (int i = 0; i <arr.length; i++) {
            if (arr[i]==score){
                flag=i;
                System.out.println("arr.index:"+i);
                break;

            }
        }
        
        if (flag==-1){
            System.out.println("arr.index not exist");
        }
    }
}

~~~



### 折半查找

​		（有序线性表）-> 需要是数组，查找的效率会大大的提高，效率会大大的得到提升

#### 使用循环

~~~java
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr= {1,2,3,4,5,6,7,8,9,10};

        int score = 3;

        int flag = -1;

        // find low and  high value
        int low=0;
        int high = arr.length-1;

        while (low < high){
            int mid=(low+high)/2;
            if(score == arr[mid]){
                System.out.println("arr.index:"+mid);
                flag = 1;
                break;
            }else if(score < arr[mid]){
                high = mid-1;
            }else {
                low = mid+1 ;
            }
        }
        if (flag==-1){
            System.out.println("arr.index not exist");
        }
    }
}
~~~

#### 使用递归

~~~java
public class BinarySearch2 {
    public static void main(String[] args) {
        int[] arr= {1,2,3,4,5,6,7,8,9,10};
        int score = 3;
        // find low and  high value
        int low=0;
        int high = arr.length-1;
        int i = binarySearch3(arr, score, low, high);
        if (i==-1){
            System.out.println("error");
        }
    }

    /**
     * 递归二分查找法
     * @param arr 目标数组
     * @param key 目标数字
     * @param low 数组0
     * @param high 数组上标
     * @return  目标数字的index
     */
    public static int binarySearch3(int[] arr,int key ,int low, int high){
        if (low>high){
            return -1;
        }
        int mid =(low +high) /2 ;
        if (key == arr[mid]){
            System.out.println(mid);
            return mid;
        }else if( key < arr[mid]){
            return binarySearch3(arr,key,low,mid-1);
        }else{
            return binarySearch3(arr,key,mid+1,high);
        }
    }
}

~~~



### 查找树

​		核心也是利用了二叉树的特点，节点的左子节点小于节点，右子节点大于节点，通过这样的方式可以快速的定位数据

### 哈希表

#### 特点

+ 根据哈希值进行查找
+ 最流行的是顺序表+链表的结构

## Java

### 红黑树

+ Java中的`TreeSet `和`TreeMap`都使用了红黑树，它是一种自动平衡的二叉树
  + `TreeSet`底层是依靠`TreeMap`来实现的
  + `HashSet` 底层是依靠`HashMap`来实现的
    + `HashMap`底层是Hash表+红黑树



